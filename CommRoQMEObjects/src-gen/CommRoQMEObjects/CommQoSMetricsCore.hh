//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Christian Schlegel (schlegel@hs-ulm.de)
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// Please do not modify this file. It will be re-generated
// running the code generator.
//--------------------------------------------------------------------------
#ifndef COMMROQMEOBJECTS_COMMQOSMETRICS_CORE_H_
#define COMMROQMEOBJECTS_COMMQOSMETRICS_CORE_H_

#include "CommRoQMEObjects/CommQoSMetricsIDL.hh"

#include <iostream>
#include <string>
#include <list>
#include <algorithm> // for using std::transform

#include "ace/Message_Block.h"

namespace CommRoQMEObjects {
	
class CommQoSMetricsCore {
private:
	// internal comm-object hash generation
	// these methods are used by std::transform (in getters and setters below) to convert string iterators
	static std::string getStlString(const ACE_CString &str) { return str.c_str(); }
	static ACE_CString getIdlString(const std::string &str) { return str.c_str(); }
	
protected:
	// PSI data structure
	CommRoQMEObjectsIDL::CommQoSMetrics idl_CommQoSMetrics;
	
public:
	// give a publicly accessible type-name for the template parameter IDL
	typedef CommRoQMEObjectsIDL::CommQoSMetrics DATATYPE;
	
	#ifdef ENABLE_HASH
		static size_t generateDataHash(const DATATYPE &);
	#endif
	
	static const char* getCompiledHash();
	static void getAllHashValues(std::list<std::string> &hashes);
	static void checkAllHashValues(std::list<std::string> &hashes);
	
	// default constructor
	CommQoSMetricsCore();
	
	// conversion constructor and operator
	CommQoSMetricsCore(const DATATYPE &commQoSMetrics) : idl_CommQoSMetrics(commQoSMetrics) {  }
	operator DATATYPE() const { return idl_CommQoSMetrics; }
	// default destructor
	virtual ~CommQoSMetricsCore();
	
	void get(ACE_Message_Block *&msg) const;
	void set(const ACE_Message_Block *msg);
	
	static inline std::string identifier(void) { return "CommRoQMEObjects::CommQoSMetrics"; }
	
	// helper method to easily implement output stream in derived classes
	void to_ostream(std::ostream &os = std::cout) const;
	
	// convert to xml stream
	void to_xml(std::ostream &os, const std::string &indent = "") const;
	
	// restore from xml stream
	void from_xml(std::istream &is);
	
	// User Interface
	
	// getter and setter for element MetricNames
	/**
	 * Getter methods for idl_CommQoSMetrics.metricNames of type vector<std::string>
	 */
	inline std::vector<std::string> getMetricNamesCopy() const {
		std::vector<std::string> copy(idl_CommQoSMetrics.metricNames.size());
		std::transform(idl_CommQoSMetrics.metricNames.begin(), idl_CommQoSMetrics.metricNames.end(), copy.begin(), getStlString);
		return copy;
	}
	inline std::string getMetricNamesElemAtPos(const size_t &pos) const { return idl_CommQoSMetrics.metricNames[pos].c_str(); }
	inline size_t getMetricNamesSize() const { return idl_CommQoSMetrics.metricNames.size(); }
	inline bool isMetricNamesEmpty() const { return idl_CommQoSMetrics.metricNames.empty(); }
	/**
	 * Setter methods for idl_CommQoSMetrics.metricNames of type vector<std::string>
	 */
	inline CommQoSMetricsCore& setMetricNames(const std::vector<std::string> &metricNames) { 
		resizeMetricNames(metricNames.size());
		std::transform(metricNames.begin(), metricNames.end(), idl_CommQoSMetrics.metricNames.begin(), getIdlString);
		return *this;
	}
	inline bool setMetricNamesElemAtPos(const size_t &pos, const std::string &elem) {
		if(pos < idl_CommQoSMetrics.metricNames.size()) {
			idl_CommQoSMetrics.metricNames[pos] = elem.c_str();
			return true;
		}
		return false;
	}
	inline bool insertMetricNamesVectorAtPos(const size_t &pos, const std::vector<std::string> &data) {
		if(pos < idl_CommQoSMetrics.metricNames.size()) {
			std::vector<ACE_CString> copy(data.size());
			std::transform(data.begin(), data.end(), copy.begin(), getIdlString);
			idl_CommQoSMetrics.metricNames.insert(idl_CommQoSMetrics.metricNames.begin()+pos, copy.begin(), copy.end());
			return true;
		}
		return false;
	}
	inline void resizeMetricNames(const size_t &size) { idl_CommQoSMetrics.metricNames.resize(size); }
	inline bool eraseMetricNamesElemsAtPos(const size_t &pos, const size_t &nbr_elems) {
		if( (pos+nbr_elems) <= idl_CommQoSMetrics.metricNames.size() ) {
			idl_CommQoSMetrics.metricNames.erase(idl_CommQoSMetrics.metricNames.begin()+pos, idl_CommQoSMetrics.metricNames.begin()+pos+nbr_elems);
			return true;
		}
		return false;
	}
	inline void clearMetricNames() { idl_CommQoSMetrics.metricNames.clear(); }
	
	// getter and setter for element Values
	/**
	 * Getter methods for idl_CommQoSMetrics.values of type vector<double>
	 */
	inline std::vector<double>& getValuesRef() { return idl_CommQoSMetrics.values; }
	inline std::vector<double> getValuesCopy() const {
		return std::vector<double>(idl_CommQoSMetrics.values.begin(), idl_CommQoSMetrics.values.end());
	}
	inline double getValuesElemAtPos(const size_t &pos) const { return idl_CommQoSMetrics.values[pos]; }
	inline size_t getValuesSize() const { return idl_CommQoSMetrics.values.size(); }
	inline bool isValuesEmpty() const { return idl_CommQoSMetrics.values.empty(); }
	/**
	 * Setter methods for idl_CommQoSMetrics.values of type vector<double>
	 */
	inline CommQoSMetricsCore& setValues(const std::vector<double> &values) { idl_CommQoSMetrics.values = values; return *this; }
	inline bool setValuesElemAtPos(const size_t &pos, const double &elem) {
		if(pos < idl_CommQoSMetrics.values.size()) {
			idl_CommQoSMetrics.values[pos] = elem;
			return true;
		}
		return false;
	}
	inline bool insertValuesVectorAtPos(const size_t &pos, const std::vector<double> &data) {
		if(pos < idl_CommQoSMetrics.values.size()) {
			idl_CommQoSMetrics.values.insert(idl_CommQoSMetrics.values.begin()+pos, data.begin(), data.end());
			return true;
		}
		return false;
	}
	inline void resizeValues(const size_t &size) { idl_CommQoSMetrics.values.resize(size); }
	inline bool eraseValuesElemsAtPos(const size_t &pos, const size_t &nbr_elems) {
		if( (pos+nbr_elems) <= idl_CommQoSMetrics.values.size() ) {
			idl_CommQoSMetrics.values.erase(idl_CommQoSMetrics.values.begin()+pos, idl_CommQoSMetrics.values.begin()+pos+nbr_elems);
			return true;
		}
		return false;
	}
	inline void clearValues() { idl_CommQoSMetrics.values.clear(); }
};

} /* namespace CommRoQMEObjects */
#endif /* COMMROQMEOBJECTS_COMMQOSMETRICS_CORE_H_ */
